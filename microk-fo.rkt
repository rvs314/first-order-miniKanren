#lang racket/unit

(require "common.rkt" "microk-sig.rkt" racket/match)

(import)
(export microk^)

;; first-order microKanren
(struct disj     (g1 g2)                  #:prefab #:name disjk)
(struct conj     (g1 g2)                  #:prefab #:name conjk)
(struct relate   (thunk description)      #:prefab #:name relatek)
(struct ==       (t1 t2)                  #:prefab #:name ==k)
(struct =/=      (t1 t2)                  #:prefab #:name =/=k)
(struct symbolo  (t)                      #:prefab #:name symbolok)
(struct stringo  (t)                      #:prefab #:name stringok)
(struct numbero  (t)                      #:prefab #:name numberok)
(struct not-symbolo (t)                   #:prefab #:name not-symbolok)
(struct not-stringo (t)                   #:prefab #:name not-stringok)
(struct not-numbero (t)                   #:prefab #:name not-numberok)
(struct bind     (bind-s bind-g)          #:prefab #:name bindk)
(struct mplus    (mplus-s1 mplus-s2)      #:prefab #:name mplusk)
(struct pause    (pause-state pause-goal) #:prefab #:name pausek)

(define (mature? s) (or (not s) (pair? s)))
(define (mature s)
  (if (mature? s) s (mature (step s))))

(define (start st g)
  (match g
    ((disjk g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conjk g1 g2)
     (step (bind (pause st g1) g2)))
    ((relatek thunk _)
     (pause st (thunk)))
    ((==k t1 t2) (state->stream (unify t1 t2 st)))
    ((=/=k t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolok t) (state->stream (typify t symbol? st)))
    ((stringok t) (state->stream (typify t string? st)))
    ((numberok t) (state->stream (typify t number? st)))
    ((not-symbolok t) (state->stream (distypify t symbol? st)))
    ((not-stringok t) (state->stream (distypify t string? st)))
    ((not-numberok t) (state->stream (distypify t number? st)))))

(define (step s)
  (match s
    ((mplusk s1 s2)
     (let ((s1 (if (mature? s1) s1 (step s1))))
       (cond ((not s1) s2)
             ((pair? s1)
              (cons (car s1)
                    (mplus s2 (cdr s1))))
             (else (mplus s2 s1)))))
    ((bindk s g)
     (let ((s (if (mature? s) s (step s))))
       (cond ((not s) #f)
             ((pair? s)
              (step (mplus (pause (car s) g)
                           (bind (cdr s) g))))
             (else (bind s g)))))
    ((pausek st g) (start st g))
    (_            s)))
